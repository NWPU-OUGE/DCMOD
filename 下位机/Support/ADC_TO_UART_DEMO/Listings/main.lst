C51 COMPILER V9.00   MAIN                                                                  06/11/2021 17:19:42 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Tools\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include<stc8.h>
   2          #include<intrins.h>
   3          #include<stdio.h>
   4          /*
   5            STC8H1K08 ADC转串口，共计四路ADC，2路串口输出
   6            产品名：影萌牌ADC转串口V1.0
   7            作者：何影萌
   8            晶蓝电子出品，必属精品
   9            版权所有 侵权必究
  10            当前已经实现四路ADC扩展，串口2正在研究中
  11          
  12            晶振为33.1776MHZ(已经达到STM32F1的一半了，就问你爽不爽)
  13            波特率为115200
  14          
  15            最方便的Printf用法：
  16            ES=0;
  17            TI=1;
  18            printf;
  19            ES=1;
  20          */
  21          
  22          
  23          void UartInit(void);    //115200bps@ 33.1776MHz
  24          void Delay_ms(unsigned int ms);   //@33.1776MHz
  25          void SendData(unsigned char dat);//发送一个字符
  26          void Send_Str(unsigned char *str);//发送一个字符串
  27          void ADC_Init();//ADC初始化
  28          unsigned int ADC_Change(unsigned char channel);//ADC转换
  29          
  30          
  31          void main()
  32          {
  33   1          unsigned int ADC_num[4];
  34   1          unsigned int ADC_ALL;
  35   1          unsigned char i;
  36   1          UartInit();   //115200bps@ 33.1776MHz
  37   1          ADC_Init();
  38   1          //Uart2Init();    //115200bps@33.1776MHz  串口2
  39   1          Delay_ms(100);    //@11.0592MHz
  40   1          while(1)
  41   1          {
  42   2              /*
  43   2              检测接收的数据是否正确，成功返回1，失败返回0
  44   2              * 使用了USART1 4Pin的接口  波特率为115200 BPS
  45   2              * 通信协议：包头+数据流+包尾+校验 共计12个字节
  46   2              * 包头：一个字节 0x2d   ADC_Read.Buf[0]
  47   2              * 数据流：两个字节ADC1 +两个字节ADC2 +两个字节ADC3 +两个字节ADC4传感 1-8
  48   2              * 校验：整理出四个ADC值相加的值发送到C板端  ADC_Read.Buf[9]   ADC_Read.Buf[10]
  49   2              * 包尾：一个字节 0x73   ADC_Read.Buf[11]
  50   2              */
  51   2              ADC_ALL=0;
  52   2              for(i=0; i<4; i++)
  53   2              {
  54   3                  ADC_num[i]=ADC_Change(1+i);
C51 COMPILER V9.00   MAIN                                                                  06/11/2021 17:19:42 PAGE 2   

  55   3                  ADC_ALL+=ADC_num[i];
  56   3              }
  57   2      
  58   2              SendData(0x2d);
  59   2              SendData(ADC_num[0]>>8);
  60   2              SendData(ADC_num[0]%0x00ff);
  61   2              SendData(ADC_num[1]>>8);
  62   2              SendData(ADC_num[1]%0x00ff);
  63   2              SendData(ADC_num[2]>>8);
  64   2              SendData(ADC_num[2]%0x00ff);
  65   2              SendData(ADC_num[3]>>8);
  66   2              SendData(ADC_num[3]%0x00ff);
  67   2              SendData(0x73);
  68   2              Delay_ms(5);    //@11.0592MHz
  69   2          }
  70   1      }
  71          
  72          
  73          
  74          
  75          void UartInit(void)   //115200bps@ 33.1776MHz
  76          {
  77   1          SCON = 0x50;    //8位数据,可变波特率
  78   1          AUXR |= 0x40;   //定时器1时钟为Fosc,即1T
  79   1          AUXR &= 0xFE;   //串口1选择定时器1为波特率发生器
  80   1          TMOD &= 0x0F;   //设定定时器1为16位自动重装方式
  81   1          TL1 = 0xB8;   //设定定时初值
  82   1          TH1 = 0xFF;   //设定定时初值
  83   1          ET1 = 0;    //禁止定时器1中断
  84   1          TR1 = 1;    //启动定时器1
  85   1          EA=1;
  86   1          ES=1;
  87   1      }
  88          
  89          void Delay_ms(unsigned int ms)    //@33.1776MHz
  90          {
  91   1          unsigned char i, j;
  92   1          while(ms--)
  93   1          {
  94   2              _nop_();
  95   2              i = 5;
  96   2              j = 76;
  97   2              do
  98   2              {
  99   3                  while (--j);
 100   3              } while (--i);
 101   2          }
 102   1      }
 103          
 104          
 105          
 106          
 107          void SendData(unsigned char dat)
 108          {
 109   1          SBUF=dat;
 110   1          while(TI==0);
 111   1          TI=0;
 112   1      }
 113          
 114          void Send_Str(unsigned char *str)
 115          {
 116   1          while(*str)
C51 COMPILER V9.00   MAIN                                                                  06/11/2021 17:19:42 PAGE 3   

 117   1          {
 118   2              SendData(*str++);
 119   2          }
 120   1      }
 121          
 122          
 123          
 124          void ADC_Init()
 125          {
 126   1          P3M0=0x00;
 127   1          P3M1=0x78;
 128   1          P_SW2 |= 0x80;  //将P_SW2寄存器的最高位EAXFR置1,访问XSFR
 129   1      //  ADCTIM=0x3f;
 130   1          P_SW2 &=0x7f;
 131   1          ADCCFG=0x02;
 132   1          ADC_CONTR|=0x80;
 133   1      }
 134          
 135          /*1:ADC11 0X0B 2:ADC12 0X0C 3:ADC13 0X0D 4:ADC14 0X0E*/
 136          unsigned int ADC_Change(unsigned char channel)
 137          {
 138   1          unsigned int ADC_Dat;
 139   1          ADC_Dat=0x00;
 140   1          ADC_RES   = 0;
 141   1          ADC_RESL  = 0;
 142   1          ADC_CONTR&=0xf0;//消除掉原有的标志，防止错误读取
 143   1          switch(channel)
 144   1          {
 145   2          case 1:
 146   2              ADC_CONTR|=0x4B;
 147   2              break;
 148   2          case 2:
 149   2              ADC_CONTR|=0x4C;
 150   2              break;
 151   2          case 3:
 152   2              ADC_CONTR|=0x4D;
 153   2              break;
 154   2          case 4:
 155   2              ADC_CONTR|=0x4E;
 156   2              break;
 157   2          }
 158   1          _nop_();
 159   1          _nop_();
 160   1          while(!(ADC_CONTR&0x20));
 161   1          ADC_CONTR&=~0x20;
 162   1          ADC_CONTR&=~0x40;
 163   1          ADC_Dat|=ADC_RES;
 164   1          ADC_Dat<<=2;
 165   1          ADC_Dat|=(ADC_RESL>>6);
 166   1      
 167   1          return ADC_Dat;
 168   1      }
 169          
 170          
 171          
 172          void UART() interrupt 4
 173          {
 174   1      
 175   1      }
 176          
 177          
 178          
C51 COMPILER V9.00   MAIN                                                                  06/11/2021 17:19:42 PAGE 4   



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    353    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      14
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
